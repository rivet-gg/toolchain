/*
 * Rivet API EE
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`matchmaker_players_connected`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchmakerPlayersConnectedError {
	Status400(crate::models::ErrorBody),
	Status403(crate::models::ErrorBody),
	Status404(crate::models::ErrorBody),
	Status408(crate::models::ErrorBody),
	Status429(crate::models::ErrorBody),
	Status500(crate::models::ErrorBody),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`matchmaker_players_disconnected`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchmakerPlayersDisconnectedError {
	Status400(crate::models::ErrorBody),
	Status403(crate::models::ErrorBody),
	Status404(crate::models::ErrorBody),
	Status408(crate::models::ErrorBody),
	Status429(crate::models::ErrorBody),
	Status500(crate::models::ErrorBody),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`matchmaker_players_get_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchmakerPlayersGetStatisticsError {
	Status400(crate::models::ErrorBody),
	Status403(crate::models::ErrorBody),
	Status404(crate::models::ErrorBody),
	Status408(crate::models::ErrorBody),
	Status429(crate::models::ErrorBody),
	Status500(crate::models::ErrorBody),
	UnknownValue(serde_json::Value),
}

/// Validates the player token is valid and has not already been consumed then marks the player as connected.  # Player Tokens and Reserved Slots  Player tokens reserve a spot in the lobby until they expire. This allows for precise matchmaking up to exactly the lobby's player limit, which is important for games with small lobbies and a high influx of players. By calling this endpoint with the player token, the player's spot is marked as connected and will not expire. If this endpoint is never called, the player's token will expire and this spot will be filled by another player.  # Anti-Botting  Player tokens are only issued by caling `lobbies.join`, calling `lobbies.find`, or from the `GlobalEventMatchmakerLobbyJoin` event. These endpoints have anti-botting measures (i.e. enforcing max player limits, captchas, and detecting bots), so valid player tokens provide some confidence that the player is not a bot. Therefore, it's important to make sure the token is valid by waiting for this endpoint to return OK before allowing the connected socket to do anything else. If this endpoint returns an error, the socket should be disconnected immediately.  # How to Transmit the Player Token  The client is responsible for acquiring the player token by caling `lobbies.join`, calling `lobbies.find`, or from the `GlobalEventMatchmakerLobbyJoin` event. Beyond that, it's up to the developer how the player token is transmitted to the lobby. If using WebSockets, the player token can be transmitted as a query parameter. Otherwise, the player token will likely be automatically sent by the client once the socket opens. As mentioned above, nothing else should happen until the player token is validated.
pub async fn matchmaker_players_connected(
	configuration: &configuration::Configuration,
	matchmaker_players_connected_request: crate::models::MatchmakerPlayersConnectedRequest,
) -> Result<(), Error<MatchmakerPlayersConnectedError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/matchmaker/players/connected",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder =
			local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
		local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
	};
	local_var_req_builder = local_var_req_builder.json(&matchmaker_players_connected_request);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		Ok(())
	} else {
		let local_var_entity: Option<MatchmakerPlayersConnectedError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// Marks a player as disconnected. # Ghost Players If players are not marked as disconnected, lobbies will result with \"ghost players\" that the matchmaker thinks exist but are no longer connected to the lobby.
pub async fn matchmaker_players_disconnected(
	configuration: &configuration::Configuration,
	matchmaker_players_connected_request: crate::models::MatchmakerPlayersConnectedRequest,
) -> Result<(), Error<MatchmakerPlayersDisconnectedError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/matchmaker/players/disconnected",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder =
			local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
		local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
	};
	local_var_req_builder = local_var_req_builder.json(&matchmaker_players_connected_request);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		Ok(())
	} else {
		let local_var_entity: Option<MatchmakerPlayersDisconnectedError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// Gives matchmaker statistics about the players in game.
pub async fn matchmaker_players_get_statistics(
	configuration: &configuration::Configuration,
) -> Result<
	crate::models::MatchmakerGetStatisticsResponse,
	Error<MatchmakerPlayersGetStatisticsError>,
> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/matchmaker/players/statistics",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder =
			local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
		local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
	};

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<MatchmakerPlayersGetStatisticsError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}
